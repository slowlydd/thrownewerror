# 垃圾回收

所有运行的程序都必须管理使用计算机内存的方式。一些语言中具有垃圾回收机制（例如我们常用的 JavaScript），在程序运行时不断寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。

## 相关概念

**内存管理**是计算机科学中的概念。不论是什么程序语言，内存管理都是指对内存生命周期的管理。那么内存的生命周期包括哪些阶段哪？

### 内存生命周期
内存生命周期分为三个阶段：

+ 分配内存空间
  + 内存是被操作系统分配，这允许程序使用它，在低级语言中（例如：C 语言），这需要开发者调用相关 API 显式操作。在高级语言中，会有 GC（Garbage Collector）帮助开发者处理。
+ 使用内存空间
  + 使用之前分配的内存空间，通常是通过操作变量对内进行读和写
+ 释放内存空间
  + 不用的时候，释放内存，以便重新分配。

在内存的整个生命周期中，理想的状况是内存能够在需要的时候有足够的空间分配给程序使用，在不用的时候应用程序能够及时将内存交还给操作系统。然而，很多时候，往往事与愿违！

### 内存溢出与内存泄漏

+ **内存溢出**（Out of Memory）：就是申请内存的时候，没有足够的内存空间。
+ **内存泄漏**（Memory Leak）：就是申请了内存，在内存不使用的时候，没有释放，导致内存空间浪费。

拿蹲坑做类比。前者可以看做是**坑位满了，你找不到坑位；后者可以看做是占着茅坑不拉那啥**。当然，两种情况都是非常糟糕的。所以，很多时候，避免两种情况的发生，就成了写代码的我们需要关注的地方。想要合理地使用内存，那么了解垃圾回收机制是必须的。

这里总是提到内存，那么我们所讲的内存到底是指哪些内存哪？
> 堆内存。

### 栈（Stack）与堆（Heap）

堆和栈都是代码在运行时可供使用的内存，但是他们的结构不同。**栈以放入值的顺序存储并以相反顺序取出值**。这也被称作后进先出（last in，first out）。**栈中的所有数据都必须占用已知且固定的大小**。在编译时，大小未知或大小可能发生变化的数据，要改为存储在堆上。

堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）**在堆的某处找到一块足够大的空间**（如果找不到，这个时候就会出现内存溢出错误），**并返回一个表示该位置地址的指针**，或者返回一个存储了该位置地址的变量，两种说法都是可以的。

当你的代码调用一个函数时，传递给函数的值（包括可能是指向堆上数据的指针）和局部变量被压入栈中。当函数结束后，这些值被移出栈。这时跟踪哪部分代码正在使用堆上的数据，减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，正是垃圾回收机制需要做的事情。那么，JavaScript 引擎的垃圾回收机制是怎样的哪？它又是如何运作的哪？

## 两种垃圾回收机制
> 垃圾回收算法依赖的主要概念是引用。

在内存管理的语境中，一个对象只要显示或隐式访问另一个对象，就可以说它引用了另一个对象。在这种情况下，”对象“的概念扩展到比普通 JavaScript 对象更广的范围，并且还包括函数作用域。

### 引用计数垃圾回收 

#### 循环引用

### 标记清除法

### 垃圾回收的行为特性

## JS 中常见的几种内存泄漏

## 如何发现与避免内存泄漏





